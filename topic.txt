import subprocess
import sys
import os

# Setup the path to the common directory to import clusters.py
common_dir = os.path.join(os.path.dirname(__file__), '..', 'common')
sys.path.insert(0, os.path.abspath(common_dir))

from clusters import CLUSTERS, switch_context, ANSIColors

ignore_namespaces = [
    "anthos-identity-service", "argocd", "argoworkflows", "bigip", "cert-manager",
    "config-management-system", "external-secrets", "gatekeeper-system", "gke-connect",
    "gke-managed-metrics-server", "gke-system", "kube-system"
]

def run_kubectl_command(cmd):
    """
    Runs a given kubectl command and prints its output.
    """
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        return result.stdout
    except subprocess.CalledProcessError as e:
        print(f"{ANSIColors.RED}Command failed: {' '.join(cmd)}\n{e.stderr}{ANSIColors.ENDC}")

def filter_namespaces(output):
    """
    Filters out lines that include any of the namespaces to ignore.
    """
    lines = output.split('\n')
    filtered_lines = [line for line in lines if not any(ns in line for ns in ignore_namespaces)]
    return '\n'.join(filtered_lines)

def print_cluster_info():
    for cluster in CLUSTERS:
        if switch_context(cluster):
            print(f"{ANSIColors.CYAN}Information for cluster: {cluster['name']}{ANSIColors.ENDC}")
            
            # Component statuses
            print(f"{ANSIColors.GREEN}Component Statuses:{ANSIColors.ENDC}")
            print(run_kubectl_command(['kubectl', 'get', 'componentstatuses']))

            # Nodes
            print(f"{ANSIColors.GREEN}Nodes:{ANSIColors.ENDC}")
            print(run_kubectl_command(['kubectl', 'get', 'nodes']))

            # Deployments
            print(f"{ANSIColors.GREEN}Deployments:{ANSIColors.ENDC}")
            deployments_output = run_kubectl_command(['kubectl', 'get', 'deployments', '--all-namespaces'])
            print(filter_namespaces(deployments_output))

            # Pods
            print(f"{ANSIColors.GREEN}Pods:{ANSIColors.ENDC}")
            pods_output = run_kubectl_command(['kubectl', 'get', 'pods', '--all-namespaces'])
            print(filter_namespaces(pods_output))

            # Pods with Restart Counts
            print(f"{ANSIColors.GREEN}Pods by Restart Count:{ANSIColors.ENDC}")
            pods_restarts_output = run_kubectl_command([
                'kubectl', 'get', 'pods', '--all-namespaces', 
                '-o', 'custom-columns=NAMESPACE:.metadata.namespace,NAME:.metadata.name,RESTARTS:.status.containerStatuses[0].restartCount'
            ])
            print(filter_namespaces(pods_restarts_output))

            # Top Pods by CPU usage
            print(f"{ANSIColors.GREEN}Top Pods by CPU:{ANSIColors.ENDC}")
            print(run_kubectl_command(['kubectl', 'top', 'pods', '--all-namespaces', '--sort-by=cpu']))

            # Top Nodes by CPU usage
            print(f"{ANSIColors.GREEN}Top Nodes by CPU:{ANSIColors.ENDC}")
            print(run_kubectl_command(['kubectl', 'top', 'nodes']))

if __name__ == "__main__":
    print_cluster_info()


import subprocess
import json
import sys
import os

# Assuming clusters.py is in the parent directory of the current script's directory, under 'common'
common_dir = os.path.join(os.path.dirname(__file__), '..', 'common')
sys.path.insert(0, os.path.abspath(common_dir))

from clusters import CLUSTERS, switch_context, ANSIColors

def get_ingresses():
    cmd = ['kubectl', 'get', 'ing', '-o', 'json', '--all-namespaces']
    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = proc.communicate()

    if proc.returncode != 0:
        print(f"{ANSIColors.RED}Error fetching ingresses: {err.decode()}{ANSIColors.ENDC}")
        return []

    ingresses = json.loads(out.decode())['items']
    urls = []
    for ing in ingresses:
        for rule in ing.get('spec', {}).get('rules', []):
            host = rule.get('host')
            if 'http' not in host:
                host = 'https://' + host
            urls.append(host + '/health')

    return urls

def check_endpoints(urls):
    status_200 = []
    status_404 = []
    other_statuses = []
    unexpected_outputs = []

    for url in urls:
        cmd = f"curl -k -s -o /dev/null -w '%{{http_code}}' {url}"
        proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        out, err = proc.communicate()

        http_status = out.decode().strip().strip("'")

        try:
            http_status_code = int(http_status)
            message = f"{url}: '{http_status_code}'"
            if http_status_code == 200:
                status_200.append(f"{message} - SSL Working Fine")
            elif http_status_code == 404:
                status_404.append(f"{ANSIColors.RED}{message} - Error 404 returned, please investigate.{ANSIColors.ENDC}")
            else:
                other_statuses.append(f"{ANSIColors.RED}{message} - Error {http_status_code} returned, please investigate.{ANSIColors.ENDC}")
        except ValueError:
            unexpected_outputs.append(f"{ANSIColors.RED}Unexpected output for {url}: {http_status}{ANSIColors.ENDC}")

    print("\n--- Status 200 ---")
    for message in status_200:
        print(message)

    print("\n--- Status 404 ---")
    for message in status_404:
        print(message)

    print("\n--- Other Statuses ---")
    for message in other_statuses:
        print(message)

    print("\n--- Unexpected Outputs ---")
    for message in unexpected_outputs:
        print(message)

def main():
    for cluster_info in CLUSTERS:
        if switch_context(cluster_info):
            print(f"{ANSIColors.CYAN}Gathering information for cluster: {cluster_info['name']}{ANSIColors.ENDC}")
            urls = get_ingresses()
            if urls:
                check_endpoints(urls)
            else:
                print(f"{ANSIColors.YELLOW}No ingresses found in cluster: {cluster_info['name']}{ANSIColors.ENDC}")
        else:
            print(f"{ANSIColors.RED}Skipping checks for cluster: {cluster_info['name']}{ANSIColors.ENDC}")

if __name__ == "__main__":
    main()
