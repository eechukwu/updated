Certainly! You can achieve the same without writing a YAML manifest file by using kubectl commands directly. Below are the steps tailored to your request:

1. Create a Deployment
Use the kubectl create deployment command to create a new deployment for your test app. We'll stick with the nginx image for simplicity:

bash
Copy code
kubectl create deployment test-app --image=nginx
This command creates a deployment named test-app using the nginx image.

2. Expose Your Deployment (Optional)
If you want your app to be accessible from outside the Kubernetes cluster, you can expose it as a service. For example, to expose it using NodePort:

bash
Copy code
kubectl expose deployment test-app --type=NodePort --port=80
This command creates a service of type NodePort for your deployment, making it accessible on a port on each node of your cluster.

3. Get Your Pod Name
You need the name of the pod created by the deployment to log into it. You can find it with:

bash
Copy code
kubectl get pods -l app=test-app -o name
This command lists the names of all pods with the label app=test-app, which should include your newly created pod.

4. Log Into Your Pod
Now, to get a shell in your container, you use kubectl exec. Replace <pod-name> with your podâ€™s name from the previous step:

bash
Copy code
kubectl exec -it <pod-name> -- /bin/sh
This will open a shell session inside your container. If the container uses a different shell or /bin/sh is not available, you might need to adjust the command accordingly.

5. Install Ping and Telnet
Inside the container, you can attempt to install ping and telnet. The installation command depends on the base image of the container. For Debian/Ubuntu-based containers, you might use:

bash
Copy code
apt-get update && apt-get install -y iputils-ping telnet
And for Alpine-based containers:

bash
Copy code
apk update && apk add iputils busybox-extras
Note:
Most containers, especially those designed for production, are minimalist and may not include package managers or the ability to easily install additional packages. If the base image of your container does not support installing new packages, you'll need to use a custom Docker image that includes the tools you need.
In many cases, especially with managed Kubernetes services, you might not have root access or the necessary permissions to install new packages inside a running container. In such scenarios, building a custom image is the recommended approach.
By following these steps, you can deploy a test application on a Kubernetes cluster, access the container, and attempt to install additional tools like ping and telnet, all without using manifest files.
